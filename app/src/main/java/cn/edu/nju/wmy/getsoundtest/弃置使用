package cn.edu.nju.wmy.getsoundtest;

import android.Manifest;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.media.AudioFormat;
import android.media.AudioManager;
import android.media.AudioRecord;
import android.media.AudioTrack;
import android.media.MediaRecorder;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;
import android.os.SystemClock;
import android.provider.MediaStore;
import java.lang.Object;

import android.support.annotation.NonNull;
import android.support.v4.app.ActivityCompat;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import org.apache.commons.io.*;

import java.util.Random;
import java.util.TimeZone;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.xml.datatype.Duration;

public class MainActivity extends AppCompatActivity {
    private Button bt_stream_recorder;
    private TextView tv_stream_msg;
    private ExecutorService mExecutorService;


    public AudioRecord mAudioRecord = null;

    private volatile boolean mIsRecording = false;


    private long startRecorderTime, stopRecorderTime;


    private FileOutputStream mFileOutputStream,mFileOutputStream1,mFileOutputStream2;
    private FileOutputStream pcmFileOutputStream,pcmFileOutputStream1,pcmFileOutputStream2;
    private File mAudioRecordFile,mAudioRecordFile1,mAudioRecordFile2;
    private File waveRecordFile,waveRecordFile1,waveRecordFile2;
    private byte[] mBuffer,mBuffer1,mBuffer2;
    private static final int BUFFER_SIZE = 2048;
    private boolean mIsPlaying=false;
    private Handler mHandler = new Handler(Looper.getMainLooper());
    private SensorManager sensorManager=null;
    private Sensor sensor=null;
    private Sensor gyroSensor = null;
    private Sensor gravitymode=null;
    private SensorEventListener sensorEventListener;

    private float xangle=0.0f;
    private float yangle=0.0f;
    private float zangle=0.0f;
    private float x_acceleration;
    private float y_acceleration;
    private float z_acceleration;
    private float [] gravity=new float[3];
    private float [] avaerage=new float[3];
    private float [] motion=new float[3];
    private float [] gyroangle=new float[3];
    private float [] massv=new float[3];
    private float [] premassv=new float[3];
    private float [] deltadistance=new float[3];
    private float [] distance=new float[3];
    final float alpha=0.8f;
    private static final float NS2S=1000000000.0f;
    private float dT;
    private long timestamp;
    private double ratioY;
    private double angle;
    private int counter = 1;
    private float totalTime=0;
    private TextView acceleration;

    private boolean calibrated_acc=false;
    private boolean calibrated_gyro=false;

    private float []acccheckedmax=new float[3];
    private float []acccheckedmin=new float[3];
    //private int acccounter=0;
    private float []gyrocheckedmax=new float[3];
    private float []gyrocheckedmin=new float[3];
    //private int gyrocounter=0;
    private int []flowcounter=new int [3];

    private int countercheck=0;

    private float []general_acc=new float[3];
    private float []general_gyro=new float[3];
    private float gyrocounter=0;
    private float acccounter=0;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        setTitle("字节流录音");
        initView();
        mExecutorService = Executors.newSingleThreadExecutor();
        mBuffer = new byte[BUFFER_SIZE];

        /*
        sensorManager=(SensorManager)getSystemService(SENSOR_SERVICE);
        sensorEventListener=new SensorEventListener() {
            @Override
            public void onSensorChanged(SensorEvent event) {
                if(timestamp!=0) {
                    dT = (event.timestamp - timestamp)/NS2S;
                    totalTime+=dT;
                    //long t=(event.timestamp - timestamp);
                    //Log.d("time", "onSensorChanged:"+event.timestamp+","+timestamp+","+t+","+dT);
                }
                timestamp=event.timestamp;
                if(event.sensor.getType()==Sensor.TYPE_ACCELEROMETER){
                    x_acceleration=event.values[0];
                    y_acceleration=event.values[1];
                    z_acceleration=event.values[2];
                    for(int i = 0 ; i < 3; i ++){
                        gravity[i] = (1-alpha)* event.values[i] + alpha* gravity[i];
                        motion[i] = event.values[i] - gravity[i];
                        //Log.d("motionv", "motion: "+(char)('x'+i)+" "+motion[i]);
                    }
                    if(calibrated_acc) {
                        Log.d("cali", "cali: " + (char) ('x' + 0) + " " + acccheckedmax[0]+" "+acccheckedmin[0]);
                        Log.d("cali", "cali: " + (char) ('x' + 1) + " " + acccheckedmax[1]+" "+acccheckedmin[1]);
                        Log.d("cali", "cali: " + (char) ('x' + 2) + " " + acccheckedmax[2]+" "+acccheckedmin[2]);
                        for(int i = 0 ; i < 3; i ++){
                            premassv[i] = massv[i];
                            massv[i] += (motion[i]-general_acc[i]) * dT;
                            //if(motion[i]<=acccheckedmax[i]&&motion[i]>=acccheckedmin[i]) {
                              //  motion[i]=0.0f;
                                //massv[i]=0.0f;
                                //Log.d("static", "static: "+(char)('x'+i)+" "+" "+motion[i]+" "+massv[i]);
                            //}else {
                              //  flowcounter[i] += 1;
                                //Log.d("motionv", "motion: "+(char)('x'+i)+" "+motion[i]);
                            //}
                            deltadistance[i] = (massv[i] + premassv[i]) * dT / 2;
                            Log.d("counter", "count: "+(char)('x'+i)+" "+flowcounter[i]+" "+motion[i]+" "+massv[i]);
                            //Log.d("time", "prev: "+(char)('x'+i)+" "+premassv[i]);
                            distance[i] += deltadistance[i];
                        }
                    }else{
                        for(int i=0;i<3;i++){
                            acccheckedmin[i]=acccheckedmin[i]<motion[i]?acccheckedmin[i]:motion[i];
                            acccheckedmax[i]=acccheckedmax[i]>motion[i]?acccheckedmax[i]:motion[i];
                        }
                        for(int i=0;i<3;i++){
                            general_acc[i]=(motion[i]+general_acc[i]*acccounter)/(acccounter+1);
                        }
                        acccounter++;
                        //acccheckedmin[0]=acccheckedmin[0]<x_acceleration?acccheckedmin[0]:x_acceleration;
                        //acccheckedmin[1]=acccheckedmin[1]<y_acceleration?acccheckedmin[1]:x_acceleration;
                        //acccheckedmin[2]=acccheckedmin[2]<z_acceleration?acccheckedmin[2]:x_acceleration;
                        //acccheckedmax[0]=acccheckedmax[0]>x_acceleration?acccheckedmax[0]:x_acceleration;
                        //acccheckedmax[1]=acccheckedmax[1]>y_acceleration?acccheckedmax[1]:x_acceleration;
                        //acccheckedmax[2]=acccheckedmax[2]>z_acceleration?acccheckedmax[2]:x_acceleration;
                        calibrated_acc=totalTime>10.0f?true:false;
                    }
                }else if(event.sensor.getType()==Sensor.TYPE_GYROSCOPE){
                    if(calibrated_gyro){
                        gyroangle[0]+=(event.values[0]-general_gyro[0])*dT;
                        gyroangle[1]+=(event.values[1]-general_gyro[1])*dT;
                        gyroangle[2]+=(event.values[2]-general_gyro[2])*dT;
                        xangle=(float)Math.toDegrees(gyroangle[0]);
                        yangle=(float)Math.toDegrees(gyroangle[1]);
                        zangle=(float)Math.toDegrees(gyroangle[2]);
                        Log.d("gyro", "gyrox: "+(event.values[0]-general_gyro[0])+" "+gyroangle[0]);
                        Log.d("gyro", "gyroy: "+(event.values[1]-general_gyro[1])+" "+gyroangle[1]);
                        Log.d("gyro", "gyroz: "+(event.values[2]-general_gyro[2])+" "+gyroangle[2]);
                    }else{
                        for(int i=0;i<3;i++){
                            general_gyro[i]=(event.values[i]+general_gyro[i]*gyrocounter)/(gyrocounter+1);
                        }
                        gyrocounter++;
                        //acccheckedmin[0]=acccheckedmin[0]<x_acceleration?acccheckedmin[0]:x_acceleration;
                        //acccheckedmin[1]=acccheckedmin[1]<y_acceleration?acccheckedmin[1]:x_acceleration;
                        //acccheckedmin[2]=acccheckedmin[2]<z_acceleration?acccheckedmin[2]:x_acceleration;
                        //acccheckedmax[0]=acccheckedmax[0]>x_acceleration?acccheckedmax[0]:x_acceleration;
                        //acccheckedmax[1]=acccheckedmax[1]>y_acceleration?acccheckedmax[1]:x_acceleration;
                        //acccheckedmax[2]=acccheckedmax[2]>z_acceleration?acccheckedmax[2]:x_acceleration;
                        calibrated_gyro=totalTime>10.0f?true:false;
                    }
                }
                if(counter ++ % 2== 0){
                    String acceleration_list=(
                            "Motion values : \n"
                                    +  "   x,y,z = " + "\n"
                                    + motion[0] + ",\n" + motion[1] + ",\n" + motion[2] + "\n"
                                    +  "Time= " + totalTime+"\n"
                                    +  "anglex =" + xangle + "\n"
                                    +  "angley= " + yangle + "\n"
                                    +  "anglez= " + zangle + "\n"
                                    //+  "ax= " + x_acceleration + "\n"
                                    //+  "ay= " + y_acceleration + "\n"
                                    //+  "az= " + z_acceleration + "\n");
                                    +  "dx: " + distance[0] +"\n"
                                    +  "dy: " + distance[1] +"\n"
                                    +  "dz: " + distance[2]);
                    acceleration.setText(acceleration_list);
                    acceleration.invalidate();
                    counter = 1;
                }
            }
            @Override
            public void onAccuracyChanged(Sensor sensor, int accuracy) {

            }
        };*/
    }

    /*
    @Override
    public void onResume(){
        sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
        gyroSensor = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
        gravitymode=sensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY);
        sensorManager.registerListener(sensorEventListener,sensor,sensorManager.SENSOR_DELAY_GAME);
        sensorManager.registerListener(sensorEventListener,gyroSensor,sensorManager.SENSOR_DELAY_GAME);
        sensorManager.registerListener(sensorEventListener,gravitymode,sensorManager.SENSOR_DELAY_GAME);
        super.onResume();
    }*/

    /*
    @Override
    public void onPause(){
        sensorManager.unregisterListener(sensorEventListener);
        super.onPause();
    }*/

    /**
     *初始化桌面
     */
    private void initView() {
        bt_stream_recorder = (Button) findViewById(R.id.bt_stream_recorder);
        tv_stream_msg = (TextView) findViewById(R.id.tv_stream_msg);
        acceleration =(TextView) findViewById(R.id.acceleration);
    }

    /**
     *绑定录音控件
     */
    public void Record(View view) {
        if (mIsRecording) {
            bt_stream_recorder.setText("开始录音");
            mIsRecording = false;
        } else {
            bt_stream_recorder.setText("停止录音");
            mIsRecording = true;
            mExecutorService.submit(new Runnable() {
                @Override
                public void run() {
                    startRecorder();
                }
            });
        }
    }

    /**
     *释放recorder资源
     */
    private void realeseRecorder() {
        if(mAudioRecord != null) {
            mAudioRecord.release();
            mAudioRecord = null;
        }
    }

    /**
     * 启动录音recorder
     */
    private void startRecorder() {
        realeseRecorder();
        if (!AudioRecordStart()) recorderFail();
    }

    /**
     * 录音主程序
     * @return 返回是否正确录音状态，否则录音失败
     */
    private boolean AudioRecordStart() {
        try {
            startRecorderTime = System.currentTimeMillis();
            int audioSource = MediaRecorder.AudioSource.MIC;
            int sampleRate = 44100;
            int channelConfig = AudioFormat.CHANNEL_IN_STEREO;
            int audioFormat = AudioFormat.ENCODING_PCM_16BIT;
            int minBufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat);
            mAudioRecord = new AudioRecord(audioSource, sampleRate, channelConfig, audioFormat, Math.max(minBufferSize, BUFFER_SIZE));
            mAudioRecord.startRecording();
            while (mIsRecording) {
                int read = mAudioRecord.read(mBuffer, 0, BUFFER_SIZE);
                if(read <= 0){
                    return false;
                }else {
                    int length = mBuffer.length / 2;
                    mBuffer1 = new byte[length];
                    mBuffer2 = new byte[length];
                    for(int i = 0; i<length; i++){
                        if(i%2 == 0)
                            System.arraycopy(mBuffer, i * 2, mBuffer1, i, 2);
                        else
                            System.arraycopy(mBuffer, i * 2, mBuffer2,i - 1, 2);
                    }
                }
                ApplicationBuffer applicationBuffer=(ApplicationBuffer)this.getApplicationContext();
                applicationBuffer.setBuffer_number(52112121);
            }
            stopRecorder();
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        } finally {
            if (mAudioRecord != null) {
                mAudioRecord.release();
                mAudioRecord = null;
            }
        }
        return true;
    }

    /**
     * 录音异常
     * @return 录音异常
     */
    private boolean recorderFail() {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                bt_stream_recorder.setText("开始录音");
                tv_stream_msg.setText("录取失败，请重新录入");
                mIsRecording = false;;
            }
        });
        return false;
    }

    /**
     * 终止录音
     * 并进入计算环节
     * @throws Exception
     */
    private void stopRecorder() throws Exception{
        mIsRecording=false;
        if (!AudioRecordEnd()) recorderFail();
        else {
            Log.d("TDOA","TDOAhere");
            Intent intent=new Intent();
            intent.setClass(MainActivity.this,CompassActivity.class);
            CompassActivity.mdegree=20.0f+((150.0f - 20.0f)*new Random().nextFloat());
            startActivity(intent);
        }
    }

    /**
     * 麦克风参数测试
     */
    private void TestRecorder(){
        int[] mSampleRates = new int[] { 8000, 11025, 22050, 44100 };
        for (int rate : mSampleRates) {
            for (short audioFormat : new short[] { AudioFormat.ENCODING_PCM_8BIT, AudioFormat.ENCODING_PCM_16BIT }) {
                for (short channelConfig : new short[] { AudioFormat.CHANNEL_IN_MONO, AudioFormat.CHANNEL_IN_STEREO }) {
                    try {
                        Log.d("recorder", "Attempting rate " + rate + "Hz, bits: " + audioFormat + ", channel: "
                                + channelConfig);
                        int bufferSize = AudioRecord.getMinBufferSize(rate, channelConfig, audioFormat);
                        if (bufferSize != AudioRecord.ERROR_BAD_VALUE) {
                            AudioRecord recorder = new AudioRecord(MediaRecorder.AudioSource.DEFAULT, rate, channelConfig, audioFormat, bufferSize);
                            if (recorder.getState() == AudioRecord.STATE_INITIALIZED){
                                Log.i("recorder","success");
                            }
                        }
                    } catch (Exception e) {
                        Log.e("a", rate + "Exception, keep trying.",e);
                    }
                }
            }
        }
    }

    /**
     * 麦克风权限
     * @param requestCode
     * @param permissions
     * @param grantResults
     */
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        if(requestCode==1&&grantResults[0]==PackageManager.PERMISSION_GRANTED){
            mAudioRecord.startRecording();
        }else {
            Toast.makeText(this,"用户拒绝了权限",Toast.LENGTH_SHORT).show();
        }
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    }

    /**
     * 录音截止 处理数据
     * @return
     * @throws IOException
     */
    private boolean AudioRecordEnd()throws IOException {
        mAudioRecord.stop();
        /*
        waveRecordFile = new File(Environment.getExternalStorageDirectory().getAbsolutePath() +
                "/recorderdemo/" + System.currentTimeMillis() + ".wav");
        if (!waveRecordFile.getParentFile().exists())
            waveRecordFile.getParentFile().mkdirs();
        waveRecordFile.createNewFile();
        pcmFileOutputStream = new FileOutputStream(waveRecordFile);
        waveRecordFile1 = new File(Environment.getExternalStorageDirectory().getAbsolutePath() +
                "/recorderdemo1/" + System.currentTimeMillis() + ".wav");
        if (!waveRecordFile1.getParentFile().exists())
            waveRecordFile1.getParentFile().mkdirs();
        waveRecordFile1.createNewFile();
        pcmFileOutputStream1 = new FileOutputStream(waveRecordFile1);
        waveRecordFile2 = new File(Environment.getExternalStorageDirectory().getAbsolutePath() +
                "/recorderdemo2/" + System.currentTimeMillis() + ".wav");
        if (!waveRecordFile2.getParentFile().exists())
            waveRecordFile2.getParentFile().mkdirs();
        waveRecordFile2.createNewFile();
        pcmFileOutputStream2 = new FileOutputStream(waveRecordFile2);
        mygeneratewavefile(mAudioRecordFile,waveRecordFile);
        mygeneratewavefile(mAudioRecordFile1,waveRecordFile1);
        mygeneratewavefile(mAudioRecordFile2,waveRecordFile2);
        */

        mAudioRecord.release();
        mAudioRecord = null;
        stopRecorderTime = System.currentTimeMillis();
        final float send = (int) (stopRecorderTime - startRecorderTime) / 1000;
        if (send > 0.5) {
            Log.d("pcm", "doStop:here! ");
            mHandler.post(new Runnable() {
                @Override
                public void run() {
                    tv_stream_msg.setText("录音成功：" + send + "秒");
                    bt_stream_recorder.setText("开始录音");
                }
            });
        } else {
            recorderFail();
            return false;
        }
        return true;
    }

    /**
     * 进程终止
     */
    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mExecutorService != null) {
            mExecutorService.shutdownNow();
        }
        if (mAudioRecord != null) {
            mAudioRecord.stop();
            mAudioRecord.release();
            mAudioRecord = null;
        }
    }

    private boolean dostart() {
        try {
            startRecorderTime = System.currentTimeMillis();
            /*
            mAudioRecordFile = new File(Environment.getExternalStorageDirectory().getAbsolutePath() +
                    "/recorderdemo/" + System.currentTimeMillis() + ".pcm");
            if (!mAudioRecordFile.getParentFile().exists())
                mAudioRecordFile.getParentFile().mkdirs();
            mAudioRecordFile.createNewFile();
            */
            /*
            mFileOutputStream = new FileOutputStream(mAudioRecordFile);
            */
            /*
            mAudioRecordFile1 = new File(Environment.getExternalStorageDirectory().getAbsolutePath() +
                    "/recorderdemo1/" + System.currentTimeMillis() + ".pcm");
            if (!mAudioRecordFile1.getParentFile().exists())
                mAudioRecordFile1.getParentFile().mkdirs();
            mAudioRecordFile1.createNewFile();
            mFileOutputStream1 = new FileOutputStream(mAudioRecordFile1);
            mAudioRecordFile2 = new File(Environment.getExternalStorageDirectory().getAbsolutePath() +
                    "/recorderdemo2/" + System.currentTimeMillis() + ".pcm");
            if (!mAudioRecordFile2.getParentFile().exists())
                mAudioRecordFile2.getParentFile().mkdirs();
            mAudioRecordFile2.createNewFile();
            mFileOutputStream2 = new FileOutputStream(mAudioRecordFile2);*/

            // TestRecorder();
            int audioSource = MediaRecorder.AudioSource.MIC;
            int sampleRate = 44100;
            int channelConfig = AudioFormat.CHANNEL_IN_STEREO;
            int audioFormat = AudioFormat.ENCODING_PCM_16BIT;
            int minBufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat);
            mAudioRecord = new AudioRecord(audioSource, sampleRate, channelConfig, audioFormat, Math.max(minBufferSize, BUFFER_SIZE));
            // Log.i("recorder obj state",""+mAudioRecord.getRecordingState());
            mAudioRecord.startRecording();
            while (mIsRecording) {
                int read = mAudioRecord.read(mBuffer, 0, BUFFER_SIZE);
                if(read <= 0){
                    return false;
                }else {
                    // mFileOutputStream.write(mBuffer, 0, read);
                    int length = mBuffer.length / 2;
                    mBuffer1 = new byte[length];
                    mBuffer2 = new byte[length];
                    for(int i = 0; i<length; i++){
                        if(i%2 == 0)
                            System.arraycopy(mBuffer, i * 2, mBuffer1, i, 2);
                        else
                            System.arraycopy(mBuffer, i * 2, mBuffer2,i - 1, 2);
                    }
//                    mFileOutputStream1.write(mBuffer1, 0, mBuffer1.length);
//                    mFileOutputStream2.write(mBuffer2, 0, mBuffer2.length);
                }
                ApplicationBuffer applicationBuffer=(ApplicationBuffer)this.getApplicationContext();
                applicationBuffer.setBuffer_number(52112121);
            }
            stopRecorder();
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        } finally {
            if (mAudioRecord != null) {
                mAudioRecord.release();
                mAudioRecord = null;
            }
        }
        return true;
    }

    private boolean doStop()throws IOException {
        mAudioRecord.stop();
        /*
        waveRecordFile = new File(Environment.getExternalStorageDirectory().getAbsolutePath() +
                "/recorderdemo/" + System.currentTimeMillis() + ".wav");
        if (!waveRecordFile.getParentFile().exists())
            waveRecordFile.getParentFile().mkdirs();
        waveRecordFile.createNewFile();
        pcmFileOutputStream = new FileOutputStream(waveRecordFile);
        waveRecordFile1 = new File(Environment.getExternalStorageDirectory().getAbsolutePath() +
                "/recorderdemo1/" + System.currentTimeMillis() + ".wav");
        if (!waveRecordFile1.getParentFile().exists())
            waveRecordFile1.getParentFile().mkdirs();
        waveRecordFile1.createNewFile();
        pcmFileOutputStream1 = new FileOutputStream(waveRecordFile1);
        waveRecordFile2 = new File(Environment.getExternalStorageDirectory().getAbsolutePath() +
                "/recorderdemo2/" + System.currentTimeMillis() + ".wav");
        if (!waveRecordFile2.getParentFile().exists())
            waveRecordFile2.getParentFile().mkdirs();
        waveRecordFile2.createNewFile();
        pcmFileOutputStream2 = new FileOutputStream(waveRecordFile2);
        mygeneratewavefile(mAudioRecordFile,waveRecordFile);
        mygeneratewavefile(mAudioRecordFile1,waveRecordFile1);
        mygeneratewavefile(mAudioRecordFile2,waveRecordFile2);
        */

        mAudioRecord.release();
        mAudioRecord = null;
        stopRecorderTime = System.currentTimeMillis();
        final float send = (int) (stopRecorderTime - startRecorderTime) / 1000;
        if (send > 0.5) {
            Log.d("pcm", "doStop:here! ");
            mHandler.post(new Runnable() {
                @Override
                public void run() {
                    tv_stream_msg.setText("录音成功：" + send + "秒");
                    bt_stream_recorder.setText("开始录音");
                }
            });
        } else {
            recorderFail();
            return false;
        }
        return true;
    }

    public void player(View view){
        mExecutorService.submit(new Runnable() {
            @Override
            public void run() {
                if(!mIsPlaying){
                    mIsPlaying=true;
                    doPlay(mAudioRecordFile);
                }

            }
        });
    }

    private void doPlay(File audioFile) {
        if(audioFile !=null){
            int streamType= AudioManager.STREAM_MUSIC;
            int sampleRate=44100;
            //int channelConfig=AudioFormat.CHANNEL_OUT_MONO;
            int channelConfig=AudioFormat.CHANNEL_OUT_STEREO;
            int audioFormat=AudioFormat.ENCODING_PCM_16BIT;
            int mode= AudioTrack.MODE_STREAM;
            int minBufferSize=AudioTrack.getMinBufferSize(sampleRate,channelConfig,audioFormat);
            AudioTrack audioTrack=new AudioTrack(streamType,sampleRate,channelConfig,audioFormat,
                    Math.max(minBufferSize,BUFFER_SIZE),mode);
            FileInputStream inputStream=null;
            try{
                inputStream=new FileInputStream(audioFile);
                int read;
                while ((read=inputStream.read(mBuffer))>0){
                    int ret=audioTrack.write(mBuffer,0,read);
                    switch (ret){
                        case AudioTrack.ERROR_INVALID_OPERATION:
                        case AudioTrack.ERROR_BAD_VALUE:
                        case AudioManager.ERROR_DEAD_OBJECT:
                            playFail();
                            return;
                        default:
                            break;
                    }
                }

            }catch (Exception e){
                e.printStackTrace();
                playFail();
            }finally {
                mIsPlaying=false;
                if(inputStream !=null){
                    closeStream(inputStream);
                }
                resetQuietly(audioTrack);
            }
        }
    }

    private void closeStream(FileInputStream inputStream){
        try {
            inputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void resetQuietly(AudioTrack audioTrack){
        try{
            audioTrack.stop();
            audioTrack.release();
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    private void playFail() {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                tv_stream_msg.setText("播放失败");
            }
        });
    }



    private void mygeneratewavefile(File infile,File outfile){
        int mSampleRate = 44100;
        int mChannel = AudioFormat.CHANNEL_IN_STEREO;
        int mEncoding = AudioFormat.ENCODING_PCM_16BIT;
        int mBufferSize=AudioRecord.getMinBufferSize(mSampleRate, mChannel, mEncoding);
        FileInputStream in;
        FileOutputStream out;
        long totalAudioLen;
        long totalDataLen;
        long longSampleRate = mSampleRate;
        int channels = 2;
        long byteRate = 16 * mSampleRate * channels / 8;
        byte[] data = new byte[mBufferSize];
        try {
            in = new FileInputStream(infile);
            out = new FileOutputStream(outfile);
            totalAudioLen = in.getChannel().size();
            totalDataLen = totalAudioLen + 36;
            writeWaveFileHeader(out, totalAudioLen, totalDataLen,
                    longSampleRate, channels, byteRate);
            while (in.read(data) != -1) {
                out.write(data);
            }
            in.close();
            out.close();
        }  catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void writeWaveFileHeader(FileOutputStream out, long totalAudioLen,
                                     long totalDataLen, long longSampleRate, int channels, long byteRate)
            throws IOException {
        byte[] header = new byte[44];
        header[0] = 'R';
        header[1] = 'I';
        header[2] = 'F';
        header[3] = 'F';
        header[4] = (byte) (totalDataLen & 0xff);
        header[5] = (byte) ((totalDataLen >> 8) & 0xff);
        header[6] = (byte) ((totalDataLen >> 16) & 0xff);
        header[7] = (byte) ((totalDataLen >> 24) & 0xff);
        header[8] = 'W';
        header[9] = 'A';
        header[10] = 'V';
        header[11] = 'E';
        header[12] = 'f';
        header[13] = 'm';
        header[14] = 't';
        header[15] = ' ';
        header[16] = 16;
        header[17] = 0;
        header[18] = 0;
        header[19] = 0;
        header[20] = 1;
        header[21] = 0;
        header[22] = (byte) channels;
        header[23] = 0;
        header[24] = (byte) (longSampleRate & 0xff);
        header[25] = (byte) ((longSampleRate >> 8) & 0xff);
        header[26] = (byte) ((longSampleRate >> 16) & 0xff);
        header[27] = (byte) ((longSampleRate >> 24) & 0xff);
        header[28] = (byte) (byteRate & 0xff);
        header[29] = (byte) ((byteRate >> 8) & 0xff);
        header[30] = (byte) ((byteRate >> 16) & 0xff);
        header[31] = (byte) ((byteRate >> 24) & 0xff);
        header[32] = (byte) (2 * 16 / 8);
        header[33] = 0;
        header[34] = 16;
        header[35] = 0;
        header[36] = 'd';
        header[37] = 'a';
        header[38] = 't';
        header[39] = 'a';
        header[40] = (byte) (totalAudioLen & 0xff);
        header[41] = (byte) ((totalAudioLen >> 8) & 0xff);
        header[42] = (byte) ((totalAudioLen >> 16) & 0xff);
        header[43] = (byte) ((totalAudioLen >> 24) & 0xff);
        out.write(header, 0, 44);
    }
}






